import numpy as np
import scipy.io as sio
from pyDOE import lhs
import torch
import torch.nn as nn
import matplotlib.pyplot as plt

# =========================================================
# STEP 1: Generate Burgers' shock dataset 
# =========================================================
nu = 0.01 / np.pi
N_x = 256
N_t = 100
tmax = 1.0
dt = 0.001

x = np.linspace(-1, 1, N_x+1)[:-1]
dx = x[1] - x[0]
k = (2 * np.pi / 2.0) * np.fft.fftfreq(N_x, d=dx)

u0 = -np.sin(np.pi * x)

t_rec = np.linspace(0, tmax, N_t)
record_indices = set([int(round(tr / dt)) for tr in t_rec])
usol = np.zeros((N_x, N_t))
time_idx = 0
usol[:, time_idx] = u0
time_idx += 1

def burgers_rhs(u):
    u_hat = np.fft.fft(u)
    u_x = np.fft.ifft(1j * k * u_hat).real
    u_xx = np.fft.ifft(-k**2 * u_hat).real
    return -u * u_x + nu * u_xx

u = u0.copy()
nsteps = int(tmax / dt)

for n in range(1, nsteps+1):
    k1 = burgers_rhs(u)
    k2 = burgers_rhs(u + 0.5*dt*k1)
    k3 = burgers_rhs(u + 0.5*dt*k2)
    k4 = burgers_rhs(u + dt*k3)
    u = u + (dt/6)*(k1 + 2*k2 + 2*k3 + k4)
    
    if n in record_indices:
        usol[:, time_idx] = u
        time_idx += 1

sio.savemat('burgers_shock.mat', {'x': x[:,None], 't': t_rec[:,None], 'usol': usol})
print("Generated burgers_shock.mat:", usol.shape)

# =========================================================
# STEP 2: PINN for Burgers' Equation (continuous time)
# =========================================================
device = torch.device('cuda' if torch.cuda.is_available() else 'cpu')

class PINN_Burgers(nn.Module):
    def __init__(self, layers):
        super(PINN_Burgers, self).__init__()
        self.layers = nn.ModuleList()
        for i in range(len(layers)-1):
            self.layers.append(nn.Linear(layers[i], layers[i+1]))
        self.activation = torch.tanh

    def forward(self, x):
        out = x
        for i in range(len(self.layers)-1):
            out = self.activation(self.layers[i](out))
        out = self.layers[-1](out)
        return out

def f_pde(model, t, x):
    u = model(torch.cat([t, x], dim=1))
    u_t = torch.autograd.grad(u, t, torch.ones_like(u), retain_graph=True, create_graph=True)[0]
    u_x = torch.autograd.grad(u, x, torch.ones_like(u), retain_graph=True, create_graph=True)[0]
    u_xx = torch.autograd.grad(u_x, x, torch.ones_like(u_x), retain_graph=True, create_graph=True)[0]
    return u_t + u * u_x - (0.01/np.pi) * u_xx

# Load dataset we just made
data = sio.loadmat('burgers_shock.mat')
x_exact = data['x']
t_exact = data['t']
Exact = data['usol']

# Training data
N_u = 100
N_f = 10000

idx_x0 = np.random.choice(x_exact.shape[0], N_u//2, replace=False)
x0 = x_exact[idx_x0,:]
u0 = Exact[idx_x0, 0][:,None]
t0 = np.zeros_like(x0)

idx_tb = np.random.choice(t_exact.shape[0], N_u//2, replace=False)
tb = t_exact[idx_tb,:]
xb_left = -np.ones_like(tb)
xb_right = np.ones_like(tb)
ub_left = Exact[0, idx_tb][:,None]
ub_right = Exact[-1, idx_tb][:,None]  # Actually irrelevant for Dirichlet zero BC

t_u_train = np.vstack([t0, tb, tb])
x_u_train = np.vstack([x0, xb_left, xb_right])
u_train = np.vstack([u0, ub_left, ub_right])

lb = np.array([t_exact.min(), x_exact.min()])
ub = np.array([t_exact.max(), x_exact.max()])
X_f = lb + (ub - lb) * lhs(2, N_f)
t_f_train = X_f[:,0:1]
x_f_train = X_f[:,1:2]

t_u_train = torch.tensor(t_u_train, dtype=torch.float32).to(device)
x_u_train = torch.tensor(x_u_train, dtype=torch.float32).to(device)
u_train = torch.tensor(u_train, dtype=torch.float32).to(device)
t_f_train = torch.tensor(t_f_train, dtype=torch.float32, requires_grad=True).to(device)
x_f_train = torch.tensor(x_f_train, dtype=torch.float32, requires_grad=True).to(device)

# Model
layers = [2] + [20]*9 + [1]
model = PINN_Burgers(layers).to(device)

optimizer = torch.optim.LBFGS(model.parameters(), max_iter=50000,
                               tolerance_grad=1e-8, tolerance_change=1e-9,
                               history_size=100, line_search_fn='strong_wolfe')

def closure():
    optimizer.zero_grad()
    u_pred = model(torch.cat([t_u_train, x_u_train], dim=1))
    mse_u = torch.mean((u_train - u_pred)**2)
    f_pred = f_pde(model, t_f_train, x_f_train)
    mse_f = torch.mean(f_pred**2)
    loss = mse_u + mse_f
    loss.backward()
    return loss

print("Training PINN...")
optimizer.step(closure)
print("Training complete.")

# =========================================================
# STEP 3: Prediction & Plotting
# =========================================================
T, X = np.meshgrid(t_exact.flatten(), x_exact.flatten())
t_star = torch.tensor(T.flatten()[:,None], dtype=torch.float32).to(device)
x_star = torch.tensor(X.flatten()[:,None], dtype=torch.float32).to(device)
u_pred = model(torch.cat([t_star, x_star], dim=1)).detach().cpu().numpy()
U_pred = np.reshape(u_pred, T.shape)

# Top panel
plt.figure(figsize=(8,5))
plt.pcolor(T, X, U_pred, cmap='jet')
plt.scatter(t_u_train.cpu(), x_u_train.cpu(), marker='x', c='white', label='Training data')
plt.colorbar()
plt.xlabel('t')
plt.ylabel('x')
plt.title('Predicted solution u(t,x)')
plt.legend()
plt.show()

# Bottom panel
snapshots = [0.25, 0.50, 0.75]
plt.figure(figsize=(8,5))
for t_s in snapshots:
    idx = np.argmin(np.abs(t_exact.flatten() - t_s))
    plt.plot(x_exact, Exact[:,idx], 'k-', label=f'Exact t={t_s}' if t_s==snapshots[0] else "")
    plt.plot(x_exact, U_pred[:,idx], '--', label=f'Pred t={t_s}' if t_s==snapshots[0] else "")
plt.xlabel('x')
plt.ylabel('u')
plt.legend()
plt.title('Comparison at snapshots')
plt.show()
